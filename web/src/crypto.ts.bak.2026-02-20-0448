import sodium from 'libsodium-wrappers';

export async function ready() {
  if (!sodium.ready) await sodium.ready;
}

// Convert base64-encoded Ed25519 public key to Uint8Array
export function fromBase64(s: string): Uint8Array {
  const bin = atob(s);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr;
}

export function toBase64(b: Uint8Array): string {
  let s = '';
  for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]);
  return btoa(s);
}

export async function ed25519pkToX25519(edPkBase64: string): Promise<Uint8Array> {
  await ready();
  const ed = fromBase64(edPkBase64);
  return sodium.crypto_sign_ed25519_pk_to_curve25519(ed);
}

export async function ed25519skToX25519(edSkBase64: string): Promise<Uint8Array> {
  await ready();
  const ed = fromBase64(edSkBase64);
  // secretKey is 64 bytes (seed || pub); convert to seed first
  // libsodium expects the full 64-byte secret key for conversion
  if (ed.length === 32) {
    // If only seed provided, expand to 64-byte secret key
    const keypair = sodium.crypto_sign_seed_keypair(ed);
    return sodium.crypto_sign_ed25519_sk_to_curve25519(keypair.privateKey);
  }
  return sodium.crypto_sign_ed25519_sk_to_curve25519(ed);
}

export async function deriveSharedSecret(ourEdSkBase64: string, theirEdPkBase64: string): Promise<Uint8Array> {
  await ready();
  const ourX = await ed25519skToX25519(ourEdSkBase64);
  const theirX = await ed25519pkToX25519(theirEdPkBase64);
  return sodium.crypto_scalarmult(ourX, theirX);
}

export async function encrypt(sharedSecret: Uint8Array, plaintext: Uint8Array): Promise<{ nonce: Uint8Array; ciphertext: Uint8Array }> {
  await ready();
  const nonce = sodium.randombytes_buf(sodium.crypto_aead_chacha20poly1305_IETF_NPUBBYTES);
  const key = sodium.crypto_generichash(32, sharedSecret);
  const ct = sodium.crypto_aead_chacha20poly1305_ietf_encrypt(plaintext, null, null, nonce, key);
  return { nonce, ciphertext: ct };
}

export async function decrypt(sharedSecret: Uint8Array, nonce: Uint8Array, ciphertext: Uint8Array): Promise<Uint8Array | null> {
  await ready();
  const key = sodium.crypto_generichash(32, sharedSecret);
  try {
    const pt = sodium.crypto_aead_chacha20poly1305_ietf_decrypt(null, ciphertext, null, nonce, key);
    return pt;
  } catch (e) {
    return null;
  }
}

